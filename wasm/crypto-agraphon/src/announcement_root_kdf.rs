//! Root key derivation for announcement messages.
//!
//! This module handles the initial key derivation for session establishment.
//! Unlike regular messages, announcements include an authentication key that
//! can be used for out-of-band authentication (e.g., comparing QR codes).

use crate::types::Role;
use crypto_cipher as cipher;
use crypto_kdf as kdf;
use crypto_kem as kem;

/// Root key derivation function for announcement messages.
///
/// Announcements are the first messages exchanged to establish a session.
/// This KDF differs from `MessageRootKdf` by also deriving an authentication key
/// that can be used for out-of-band verification.
///
/// # Protocol Context
///
/// The announcement phase works as follows:
/// 1. Alice (initiator) generates fresh randomness and creates an announcement to Bob
/// 2. The announcement contains a KEM ciphertext encrypted to Bob's static public key
/// 3. Bob decrypts the announcement and extracts the auth_payload
/// 4. Both parties can use `auth_key` for out-of-band authentication
/// 5. After verification, both parties establish an `Agraphon` session
///
/// # Security Properties
///
/// The auth_key provides authentication binding:
/// - It's derived from both the randomness and the KEM shared secret
/// - It can be compared over an authenticated channel (e.g., QR code scan)
/// - This prevents man-in-the-middle attacks during session establishment
///
/// # Cryptographic Details
///
/// Uses HKDF with:
/// - Salt: `"session.announcement_root_kdf.salt"`
/// - Inputs: randomness, shared_secret, ciphertext, peer_public_key, Role::Initiator
/// - Info strings: `"session.announcement_root_kdf.cipher_key"`,
///   `"session.announcement_root_kdf.cipher_nonce"`,
///   `"session.announcement_root_kdf.auth_key"`, and
///   `"session.announcement_root_kdf.integrity_seed"`
pub(crate) struct AnnouncementRootKdf {
    /// Cipher key for encrypting the announcement payload
    pub(crate) cipher_key: cipher::Key,
    /// Nonce for the cipher (derived, not random)
    pub(crate) cipher_nonce: cipher::Nonce,
    /// Authentication key for out-of-band verification
    pub(crate) auth_key: [u8; 32],
    /// Seed for deriving the integrity key and initial master key
    pub(crate) integrity_seed: [u8; 32],
}

impl AnnouncementRootKdf {
    /// Derives announcement encryption and authentication keys.
    ///
    /// # Arguments
    ///
    /// * `randomness` - Fresh randomness generated by the initiator
    /// * `ss` - Shared secret from KEM encapsulation to peer's static key
    /// * `ct` - KEM ciphertext (for domain separation)
    /// * `pk` - Peer's static public key
    ///
    /// # Returns
    ///
    /// An `AnnouncementRootKdf` containing cipher keys, auth key, and integrity seed.
    ///
    /// # Examples
    ///
    /// ```ignore
    /// // Internal module, not directly accessible from public API
    /// use crypto_kem as kem;
    /// use crypto_rng as rng;
    ///
    /// // Generate Bob's key pair
    /// let mut bob_rand = [0u8; kem::KEY_GENERATION_RANDOMNESS_SIZE];
    /// rng::fill_buffer(&mut bob_rand);
    /// let (bob_sk, bob_pk) = kem::generate_key_pair(bob_rand);
    ///
    /// // Alice creates announcement to Bob
    /// let mut randomness = [0u8; 32];
    /// rng::fill_buffer(&mut randomness);
    ///
    /// let mut enc_rand = [0u8; kem::ENCAPSULATION_RANDOMNESS_SIZE];
    /// rng::fill_buffer(&mut enc_rand);
    /// let (ct, ss) = kem::encapsulate(&bob_pk, enc_rand);
    ///
    /// let kdf = AnnouncementRootKdf::new(&randomness, &ss, &ct, &bob_pk);
    /// // kdf.auth_key can be shown to user for verification
    /// // kdf.cipher_key encrypts the announcement payload
    /// ```
    pub(crate) fn new(
        randomness: &[u8; 32],
        ss: &kem::SharedSecret,
        ct: &kem::Ciphertext,
        pk: &kem::PublicKey,
    ) -> Self {
        let mut cipher_key = [0u8; cipher::KEY_SIZE];
        let mut cipher_nonce = [0u8; cipher::NONCE_SIZE];
        let mut auth_key = [0u8; 32];
        let mut integrity_seed = [0u8; 32];

        let mut root_kdf = kdf::Extract::new("session.announcement_root_kdf.salt".as_bytes());
        root_kdf.input_item(randomness.as_slice());
        root_kdf.input_item(ss.as_bytes());
        root_kdf.input_item(ct.as_bytes());
        root_kdf.input_item(pk.as_bytes());
        root_kdf.input_item(&Role::Initiator.to_bytes());
        let root_kdf = root_kdf.finalize();
        root_kdf.expand(
            "session.announcement_root_kdf.cipher_key".as_bytes(),
            &mut cipher_key,
        );
        root_kdf.expand(
            "session.announcement_root_kdf.cipher_nonce".as_bytes(),
            &mut cipher_nonce,
        );
        root_kdf.expand(
            "session.announcement_root_kdf.auth_key".as_bytes(),
            &mut auth_key,
        );
        root_kdf.expand(
            "session.announcement_root_kdf.integrity_seed".as_bytes(),
            &mut integrity_seed,
        );

        Self {
            cipher_key: cipher_key.into(),
            cipher_nonce: cipher_nonce.into(),
            auth_key,
            integrity_seed,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crypto_rng as rng;

    #[test]
    fn test_announcement_root_kdf_deterministic() {
        let randomness = [7u8; 32];

        let mut pk_rand = [0u8; kem::KEY_GENERATION_RANDOMNESS_SIZE];
        rng::fill_buffer(&mut pk_rand);
        let (_, pk) = kem::generate_key_pair(pk_rand);

        let mut enc_rand = [0u8; kem::ENCAPSULATION_RANDOMNESS_SIZE];
        rng::fill_buffer(&mut enc_rand);
        let (ct, ss) = kem::encapsulate(&pk, enc_rand);

        let kdf1 = AnnouncementRootKdf::new(&randomness, &ss, &ct, &pk);
        let kdf2 = AnnouncementRootKdf::new(&randomness, &ss, &ct, &pk);

        assert_eq!(kdf1.cipher_key.as_bytes(), kdf2.cipher_key.as_bytes());
        assert_eq!(kdf1.cipher_nonce.as_bytes(), kdf2.cipher_nonce.as_bytes());
        assert_eq!(kdf1.auth_key, kdf2.auth_key);
        assert_eq!(kdf1.integrity_seed, kdf2.integrity_seed);
    }

    #[test]
    fn test_announcement_root_kdf_different_randomness() {
        let randomness1 = [7u8; 32];
        let randomness2 = [8u8; 32];

        let mut pk_rand = [0u8; kem::KEY_GENERATION_RANDOMNESS_SIZE];
        rng::fill_buffer(&mut pk_rand);
        let (_, pk) = kem::generate_key_pair(pk_rand);

        let mut enc_rand = [0u8; kem::ENCAPSULATION_RANDOMNESS_SIZE];
        rng::fill_buffer(&mut enc_rand);
        let (ct, ss) = kem::encapsulate(&pk, enc_rand);

        let kdf1 = AnnouncementRootKdf::new(&randomness1, &ss, &ct, &pk);
        let kdf2 = AnnouncementRootKdf::new(&randomness2, &ss, &ct, &pk);

        // Different randomness should produce different keys
        assert_ne!(kdf1.auth_key, kdf2.auth_key);
    }
}
